
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [一 Java基础](#一-java基础)
  - [一致性hash算法](#一致性hash算法)
  hash算法无法解决节点增加删除的情况
  一致性Hash算法是对2^32取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环
  一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。
  -[Hash环的数据倾斜问题] 一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜
  一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点
  同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射
  - [sleep和wait的区别](#sleep和wait的区别):sleep属于Thread;wait属于Object;
  sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。线程不会释放对象锁
  wait()方法，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
  sleep方法可以在任何地方使用；wait方法只能在同步方法和同步代码块中使用
  - [强软弱虚引用](#强软弱虚引用)涉及JVM
  - [Arrays.sort原理](#arrayssort原理)涉及算法
  在数组的数量小于47的情况下使用插入排序,在大于或等于47或少于286会进入快速排序（双轴快排）大于286采用归并排序
  - [创建对象的方式](#创建对象的方式)
  1.使用new关键字创建对象应该是最常见的一种方式，但我们应该知道，使用new创建对象会增加耦合度。无论使用什么框架，都要减少new的使用以降低耦合度。
  2.使用反射的机制创建对象:使用Class类的newInstance方法;使用Constructor类的newInstance方法
  3.采用clone:clone时，需要已经有一个分配了内存的源对象，创建新对象时，首先应该分配一个和源对象一样大的内存空间。要调用clone方法需要实现Cloneable接口
  4.采用序列化机制Z:使用序列化时，要实现Serializable接口，将一个对象序列化到磁盘上，而采用反序列化可以将磁盘上的对象信息转化到内存中。
  扩展：序列化优点：
       1.将对象转为字节流存储到硬盘上，当JVM停机的话，字节流还会在硬盘上默默等待，等待下一次JVM的启动，把序列化的对象，通过反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间（永久性保存对象）。
       2序列化成字节流形式的对象可以进行网络传输(二进制形式)，方便了网络传输。
       3.通过序列化可以在进程间传递对象。
       4.java.io.ObjectOutputStream是实现序列化的关键类,它可以将一个对象转换成二进制流，然后可以通过ObjectInputStream将二进制流还原成对象
  - [Java序列化](#java序列化)
    transient用于修饰不需要序列化的字段，如果一个引用类型被transient修饰，则其反序列化的值为null，如果一个基本类型被transient修饰，则其反序列化的值为0
       ，如果字段的引用类型是不可序列化的类，则也应该使用transient修饰，它在序列化时会被直接跳过。
       静态成员变量不属于对象，所以不会参与序列化过程。其次用transient关键字标记的成员变量不参与序列化过程。
       实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上
       利用序列化实现远程通信，即：能够在网络上传输对象。
  - [serializable 的序列化，其中 uuid 的作用](#serviable-的序列化其中-uuid-的作用)
    反序列化的时候会通过uuid进行校验，如果没有uuid,类修改字段会导致反序列化失败。
  - [浅克隆与深克隆有什么区别，如何实现深克隆](#浅克隆与深克隆有什么区别如何实现深克隆)
  浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
  深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。
  1.基本数据类型存储在栈中，引用数据类型存储在堆中。
  2.浅克隆对于一个只含有基本数据类型的类来说使用clone方法，是完全没有问题的,数据互不影响。引用数据类型会相互影响，这样就需要进行深克隆。
  3.浅克隆不会克隆原对象中的引用类型，仅仅拷贝了引用类型的指向。深克隆则拷贝了所有
  4.深克隆的另一种方法就是使用序列化，将对象写入到流中，这样对象的内容就变成了字节流，也就不存在什么引用了
  - [若hashcode方法永远返回1会产生什么结果](#若hashcode方法永远返回1会产生什么结果)
  所以对象都会哈希冲突，hashCode()本身的性能也会降级。做hash的key的时候效率会极度变低。变量比较也会变慢
  - [解决hash冲突的三种方法](#解决hash冲突的三种方法)   
  解决哈希冲突的三种方法（拉链法、开放地址法、再哈希法）
  **开放地址法**：
  1.线性探测再散列
这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。
2.二次探测再散列
这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。
3.伪随机探测再散列
di=伪随机数序列。具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。
**再哈希法**
这种方法是同时构造多个不同的哈希函数：
Hi=RH1（key） i=1，2，…，k
当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。
**链地址法**
这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。
**建立公共溢出区**
**这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。
开放散列（open hashing）/ 拉链法（针对桶链结构）**
优点：
①对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销）
②由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了
③删除记录时，比较方便，直接通过指针操作即可
缺点：
①存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销
②如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列
③由于使用指针，记录不容易进行序列化（serialize）操作
**封闭散列（closed hashing）/ 开放定址法**
优点：
①记录更容易进行序列化（serialize）操作
②如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的
缺点：
①存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷
②使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低
③由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费
④删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操
  - [动态代理](#动态代理)
  - [java 地址和值传递的例子](#java-地址和值传递的例子)
     1.值传递，传递值，在函数中形参发生的变化不影响实参。
     2.引用传递，传递对象引用，在函数中形参发生的变化影响实参。
     实际上java参数传递只有一种情况，那就是值传递。所不同的是，一般说的"引用传递"，在实际中传递的不过是引用对象的地址值
     赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。
     需要了解new一个对象的过程
  - [java NIO，java 多线程、线程池，java 网络编程解决并发量](#java-niojava-多线程-线程池java-网络编程解决并发量)
  - [JDBC 连接的过程 ，手写 jdbc 连接过程](#jdbc-连接的过程-手写-jdbc-连接过程)
  1.注册数据库驱动
  Class.forName("com.mysql.jdbc.Driver");
  2.取得数据库连接对象Connection
  Connection conn=DriverManager.getConnection(url,user,password);
  3.创建SQL执行对象
  3.1 编写sql语句sql = ...;
  3.2 获得语句执行对象
  PrepardStatement ps = conn.getprepareStatement(sql);
  4.执行SQL命令，并返回结果集
  4.1 增删改操作
  ps.executeUpdate();
  4.2 返回结果集
  ResultSet rs = ps.executeQuery();
  5.处理结果集
  while(rs.next()){ rs.getString(int i); }
  6.依次关闭结果集
  rs.close(); ps.close(); conn.close();
  - [statement 和 prestatement 的区别](#statement-和-prestatement-的区别)
  statement.createStatement;prestatement.prepareStatement;
  1.概念上
    prepareStatement会先初始化SQL，先把这个SQL提交到数据库中进行预处理，多次使用可提高效率。
    createStatement不会初始化，没有预处理，每次都是从0开始执行SQL
  2.变量上
    prepareStatement可以在SQL中用?替换变量；
    createStatement不支持 ? 替换变量，只能在sql中拼接参数；
  3.功能上
    如果想要删除三条数据
    对于createStatement，需要写三条语句
    而prepareStatement，通过set不同数据只需要生成一次执行计划，可以重用
    PreparedStatement是预编译的,对于批量处理可以大大提高效率.也叫JDBC存储过程。
    使用createStatement 对象。在对数据库只执行一次性存取的时侯，用 createStatement对象进行处理。PreparedStatement对象的开销比createStatement大，对于一次性操作并不会带来额外的好处。
    createStatement每次执行sql语句，相关数据库都要执行sql语句的编译，preparedstatement是预编译得,preparedstatement支持批处理
  4.可重复性
      对于上面的两段代码而言：createStatement必须给定一个值
      而preparedstatement，对象的key，value都可以自己定义，而且大多数情况下这个语句已经被预编译过，因而当其执行时，只需DBMS运行SQL语句，而不必先编译。这种转换实现不必重复SQL语句的句法，而只需更改其中变量的值，便可重新执行SQL语句。
      选择PreparedStatement对象与否，在于相同句法的SQL语句是否执行了多次，而且两次之间的差别仅仅是变量的不同。如果仅仅执行了一次的话，它应该和普通的对象毫无差异，体现不出它预编译的优越性。
  - [说出三个遇到过的程序报异常的情况](#说出三个遇到过的程序报异常的情况)
  - [socket 是靠什么协议支持的](#socket-是靠什么协议支持的)
  - [java io 用到什么设计模式](#java-io-用到什么设计模式)
  - [什么情景下会用到反射](#什么情景下会用到反射)
  - [反射能够使用私有的方法属性吗和底层原理？](#反射能够使用私有的方法属性吗和底层原理)
  - [处理器指令优化有些什么考虑？](#处理器指令优化有些什么考虑)
  - [object 对象的常用方法](#object-对象的常用方法)- [为什么要重写hashCode()方法和equals()方法以及如何进行重写](#为什么要重写hashcode方法和equals方法以及如何进行重写)
    Object类中的三个常用方法：toString()、equals()、hashCode()
    1.取得对象信息的方法：toString() 该方法在打印对象时被调用，将对象信息变为字符串返回，默认输出对象地址。
    2.对象相等判断方法：equals() 该方法用于比较对象是否相等，而且此方法必须被重写。equals()方法比较的是两个对象的地址
    3.对象签名:hashCode() 该方法用来返回其所在对象的物理地址（哈希码值）
    字符串对象的哈希码根据以下公式计算：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
    使用 int 算法，这里 s[i] 是字符串的第 i 个字符，n 是字符串的长度，^ 表示求幂。空字符串的哈希值为 0。
  - [Stack 和 ArrayList 的区别](#stack-和-arraylist-的区别)
  - [手写模拟实现一个阻塞队列](#手写模拟实现一个阻塞队列)
  - [util 包下有哪几种接口](#util-包下有哪几种接口)
  - [很常见的 Nullpointerexception ，你是怎么排查的，怎么解决的；](#很常见的-nullpointerexception-你是怎么排查的怎么解决的)
  - [静态内部类和非静态内部类的区别是什么？](#静态内部类和非静态内部类的区别是什么) - [怎么创建静态内部类和非静态内部类？](#怎么创建静态内部类和非静态内部类)
    一个类的内部又定义了一个类，这个类就称之为内部类（Inner Class）
    1.内部类可以访问其所在类的属性（包括所在类的私有属性），内部类创建自身对象需要先创建其所在类的对象
    2.可以定义内部接口，且可以定义另外一个内部类实现这个内部接口
    3.可以在方法体内定义一个内部类，方法体内的内部类可以完成一个基于虚方法形式的回调操作
    4.内部类不能定义static元素
    5.内部类可以多嵌套
    6.static内部类是内部类中一个比较特殊的情况，Java文档中是这样描述static内部类的：一旦内部类使用static修饰，那么此时这个内部类就升级为顶级类。、
    static内部类具备所有外部类的特性
    内部接口自动具备静态属性
    内部类：
    1、内部类中的变量和方法不能声明为静态的。
    2、内部类实例化：B是A的内部类，实例化B：A.B b = new A().new B()。
    3、内部类可以引用外部类的静态或者非静态属性及方法。

    静态内部类：
    1、静态内部类属性和方法可以声明为静态的或者非静态的。
    2、实例化静态内部类：B是A的静态内部类，A.B b = new A.B()。
    3、静态内部类只能引用外部类的静态的属性及方法。
    
  - [Xml 解析方式，原理优缺点](#xml-解析方式原理优缺点)
  XML 的解析方式分为四种：1、DOM 解析；2、SAX 解析；3、JDOM 解析；4、DOM4J解析。
  其中前两种属于基础方法，是官方提供的平台无关的解析方式；后两种属于扩展方法，它们是在基础的方法上扩展出来的，只适用于 Java 平台。
  如果 XML 文档较大且不考虑移植性问题建议采用 DOM4J；如果 XML 文档较小则建议采用 JDOM；如果需要及时处理而不需要保存数据则考虑SAX。
  1.DOM 解析 
    优点：
    形成了树结构，有助于更好的理解、掌握，且代码容易编写。
    解析过程中，树结构保存在内存中，方便修改。
    缺点：
    由于文件是一次性读取，所以对内存的耗费比较大。
    如果XML文件比较大，容易影响解析性能且可能会造成内存溢出。
  2.SAX 解析
    优点：
      采用事件驱动模式，对内存耗费比较小。
      适用于只处理XML文件中的数据时。
    缺点：
      编码比较麻烦。
      很难同时访问XML文件中的多处不同数据。
   3.JDOM 解析
      特征：
      仅使用具体类，而不使用接口。
      API 大量使用了 Collections 类。

  4、DOM4J 解析
    特征：
       JDOM的一种智能分支，它合并了许多超出基本XML文档表示的功能。
       它使用接口和抽象基本类方法。
       具有性能优异、灵活性好、功能强大和极端易用的特点。
       是一个开放源码的文件
  - [静态变量和全局变量的区别](#静态变量和全局变量的区别)
  java中就没有全局变量这个概念，只分为成员变量和局部变量。
  成员变量：Static修饰成为类变量或静态变量，还有就是方法外的变量。生命周期与类相同。
  局部变量：就是方法中的变量。生命周期就是再次方法中。
  但是，很多人学习都是先学习的C语言，C语言中存在全局变量这个概念，所以，大家对于Java中的成员变量有时候也称之为全局变量，
  同时也存在如下的一个约定俗成的小区别
  使用static 关键字进行声明的变量叫做全局变量
  在函数外面定义的变量叫做成员变量
  成员变量定义在类中，在整个类中都可以被访问。成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。
  成员变量有默认初始化值。
  局部变量只定义在局部范围内，如：函数内，语句内等，只在所属的区域有效。
  局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。局部变量没有默认初始化值 
  在使用变量时需要遵循的原则为：就近原则首先在局部范围找，有就使用；接着在成员位置找。
  静态变量（也叫做类变量，类属性）由static修饰的变量称为静态变量，其实质上就是一个全局变量。
  如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；没有被静态修饰的内容，其实是属于对象的特殊描述。
  成员变量和静态变量的区别
  1.两个变量的生命周期不同成员变量随着对象的创建而存在，随着对象被回收而释放。静态变量随着类的加载而存在，随着类的消失而消失。
  2.调用方式不同成员变量只能被对象调用。静态变量可以被对象调用，还可以被类名调用。
  3.别名不同成员变量也称为实例变量。静态变量也称为类变量。
  4.数据存储位置不同成员变量存储在堆内存的对象中，所以也叫对象的特有数据。静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。
- [二 Java集合](#二-java集合)
  -[HashMap中的重要参数]
   /** 
     * 主要参数 同  JDK 1.7 
     * 即：容量、加载因子、扩容阈值（要求、范围均相同）
     */
    // 1. 容量（capacity）： 必须是2的幂 & <最大容量（2的30次方）
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 默认容量 = 16 = 1<<4 = 00001中的1向左移4位 = 10000 = 十进制的2^4=16
    static final int MAXIMUM_CAPACITY = 1 << 30; // 最大容量 =  2的30次方（若传入的容量过大，将被最大值替换）
    // 2. 加载因子(Load factor)：HashMap在其容量自动增加前可达到多满的一种尺度 
    final float loadFactor; // 实际加载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认加载因子 = 0.75
    // 3. 扩容阈值（threshold）：当哈希表的大小 ≥ 扩容阈值时，就会扩容哈希表（即扩充HashMap的容量） 
    // a. 扩容 = 对哈希表进行resize操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数
    // b. 扩容阈值 = 容量 x 加载因子
    int threshold;
    // 4. 其他
    transient Node<K,V>[] table;  // 存储数据的Node类型 数组，长度 = 2的幂；数组的每个元素 = 1个单链表
    transient int size;// HashMap的大小，即 HashMap中存储的键值对的数量
    /** 
     * 与红黑树相关的参数
     */
     // 1. 桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 > 该值时，则将链表转换成红黑树
     static final int TREEIFY_THRESHOLD = 8; 
     // 2. 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 < 6时，则将 红黑树转换成链表
     static final int UNTREEIFY_THRESHOLD = 6;
     // 3. 最小树形化容量阈值：即 当哈希表中的容量 > 该值时，才允许树形化链表 （即 将链表 转换成红黑树）
     // 否则，若桶内元素太多时，则直接扩容，而不是树形化
     // 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD
     static final int MIN_TREEIFY_CAPACITY = 64;
  - [hashmap的jdk1.7和jdk1.8区别](#hashmap的jdk17和jdk18区别)
  1.数据结构：引入了 红黑树 由数组+链表 =》数组+链表+红黑树
  - [concurrenthashmap的jdk1.7和jdk1.8区别](#concurrenthashmap的jdk17和jdk18区别)
  - [HashMap 实现原理，扩容因子过大过小的缺点，扩容过程 采用什么方法能保证每个 bucket 中的数据更均匀 解决冲突的方式，还有没有其他方式（全域哈希）](#hashmap-实现原理扩容因子过大过小的缺点扩容过程-采用什么方法能保证每个-bucket-中的数据更均匀-解决冲突的方式还有没有其他方式全域哈希)
  HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做Entry。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。
   根据hash值和数组长度算出索引值
   h & (length-1);  //这里不能随便算取，用hash&(length-1)是有原因的，这样可以确保算出来的索引是在数组大小范围内，不会超出
  取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。
  如果不是2的整数次幂 最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大
  **扩容因子过大过小的缺点**
  加载因子越大，填满的元素越多，空间利用率越高，但发生冲突的机会变大了；
  加载因子越小，填满的元素越少，冲突发生的机会减小，但空间浪费了更多了，而且还会提高扩容rehash操作的次数。
  选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择
  当HashMap中的元素个数超过数组大小loadFactor（扩容因子）时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。
  也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为 2*16=32，
  即扩大一倍，然后重新计算每个元素在数组中的位置，扩容是需要进行数组复制的，复制数组是非常消耗性能的操作，
  所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。

  - [Collection 集合类中只能在 Iterator 中删除元素的原因](#collection-集合类中只能在-iterator-中删除元素的原因)
  - [ArrayList、LinkedList、Vector](#arraylist-linkedlist-vector)
  - [还了解除 util 其他包下的 List 吗？](#还了解除-util-其他包下的-list-吗)
  - [CopyOnWriteArrayList](#copyonwritearraylist)
  - [ConcurrentHashMap 和 LinkedHashMap 差异和适用情形](#concurrenthashmap-和-linkedhashmap-差异和适用情形)
  - [ConcurrentHashMap分段锁是如何实现，ConcurrentHashmap jdk1.8 访问的时候是怎么加锁的，插入的时候是怎么加锁的 访问不加 锁插入的时候对头结点加锁](#concurrenthashmap分段锁是如何实现concurrenthashmap-jdk18-访问的时候是怎么加锁的插入的时候是怎么加锁的-访问不加-锁插入的时候对头结点加锁)
  - [ArrayDeque 的使用场景](#arraydeque-的使用场景)
  - [ArrayBlockingQueue 源码](#arrayblockingqueue-源码)
  - [hashmap 和 treemap 的区别](#hashmap-和-treemap-的区别)
  （1）HashMap:适用于在Map中插入、删除和定位元素。
  （2）Treemap:适用于按自然顺序或自定义顺序遍历键（key）。
  （3）HashMap通常比TreeMap快一点（树和哈希表的数据结构使然），建议多使用HashMap,在需要排序的Map时候才用TreeMap.
  （4）HashMap 非线程安全 TreeMap 非线程安全
  （5）HashMap的结果是没有排序的，而TreeMap输出的结果是排好序的。
  - [hashmap](#hashmap)
  - [treemap](#treemap)
  TreeMap实现了NavigableMap接口，而NavigableMap接口继承着SortedMap接口，致使我们的TreeMap是有序的！
  TreeMap底层是红黑树，它方法的时间复杂度都不会太高:log(n)~
  非同步
  使用Comparator或者Comparable来比较key是否相等与排序的问题
  - [rehash 过程](#rehash-过程)
  HashMap需要扩展它的长度，也就是进行Resize。
  1.Capacity
  HashMap的当前长度。上一期曾经说过，HashMap的长度是2的幂。
  2.LoadFactor
  HashMap负载因子，默认值为0.75f。
  1.**扩容**
  创建一个新的Entry空数组，长度是原数组的2倍。
  2.**ReHash**
  遍历原Entry数组，把所有的Entry重新Hash到新数组。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。
  - [HashMap 的负载因子，为什么容量为2^n](#hashmap-的负载因子为什么容量为2n)
  h*length-1 减少哈希冲突，减少空间浪费。负载因子是0.75，初始长度16。 超过12会扩容
  - [list,map,set 之间的区别](#listmapset-之间的区别)
  - [什么时候会用到 HashMap](#什么时候会用到-hashmap)
  - [常见的线程安全的集合类](#常见的线程安全的集合类)
- [三 JVM](#三-jvm)
  - [反射在jvm层面的实现](#反射在jvm层面的实现)
  - [jvm的方法区存什么？](#jvm的方法区存什么)
  - [JDK1.8 JVM方法区变成了什么，为什么这样做](#jdk18-jvm方法区变成了什么为什么这样做)
  - [oom出现的原因](#oom出现的原因)
  - [Class.forName和ClassLoader的区别](#classforname和classloader的区别)
  - [java对象信息分配](#java对象信息分配)
  - [java虚拟机ZGC详解](#java虚拟机zgc详解)
  - [java虚拟机CMS详解](#java虚拟机cms详解)
  - [java虚拟机G1详解](#java虚拟机g1详解)
  - [JVM tomcat 容器启动，jvm 加载情况描述](#jvm-tomcat-容器启动jvm-加载情况描述)
- [四 多线程并发](#四-多线程并发)
  - [volitale使用场景](#volitale使用场景)
  - [可重入锁,实现原理](#可重入锁实现原理)
  - [Java 无锁原理](#java-无锁原理)
  - [讲讲多线程，多线程的同步方法](#讲讲多线程多线程的同步方法)
  - [synchronized原理](#synchronized原理)
  - [reetrantlock](#reetrantlock)
  - [java 线程安全都体现在哪些方面](#java-线程安全都体现在哪些方面)
  - [如果维护线程安全 如果想实现一个线程安全的队列，可以怎么实现？](#如果维护线程安全-如果想实现一个线程安全的队列可以怎么实现)
  - [Java多线程通信方式](#java多线程通信方式)
  - [CountDownLatch、CyclicBarrier、Semaphore 用法总结](#countdownlatch-cyclicbarrier-semaphore-用法总结)
  - [juc下的内容](#juc下的内容)
  - [AOS等并发相关面试题](#aos等并发相关面试题)
  - [threadlocal](#threadlocal)
  - [java 线程池达到提交上限的具体情况 ，线程池用法，Java 多线程，线程池有哪几类，每一类的差别](#java-线程池达到提交上限的具体情况-线程池用法java-多线程线程池有哪几类每一类的差别)
  - [要你设计的话，如何实现一个线程池](#要你设计的话如何实现一个线程池)
  - [线程池的类型，固定大小的线程池内部是如何实现的，等待队列是用了哪一个队列实现 线程池种类和工作流程](#线程池的类型固定大小的线程池内部是如何实现的等待队列是用了哪一个队列实现-线程池种类和工作流程)
  - [线程池使用了什么设计模式](#线程池使用了什么设计模式)
  - [线程池使用时一般要考虑哪些问题](#线程池使用时一般要考虑哪些问题)
  - [线程池的配置](#线程池的配置)
  - [Excutor 以及 Connector 的配置](#excutor-以及-connector-的配置)
- [五 Java框架（ssm）](#五-java框架ssm)
- [hibernate](#hibernate)
  - [Hibernate 的生成策略](#hibernate-的生成策略)
  - [Hibernate 与 Mybatis 区别](#hibernate-与-mybatis-区别)
  - [Mybatis原理](#mybatis原理)
  - [mybatis执行select的过程](#mybatis执行select的过程)
  - [mybatis有哪些executors](#mybatis有哪些executors)
  - [mybatis插件原理](#mybatis插件原理)
  - [mybatis二级缓存](#mybatis二级缓存)
- [spring&springmvc](#springspringmvc)
  - [spring中的设计模式](#spring中的设计模式)
  - [spring中bean的作用域](#spring中bean的作用域)
  - [BeanFactory和FactoryBean区别](#beanfactory和factorybean区别)
  - [aspect的种类](#aspect的种类)
  - [spring aop的实际应用](#spring-aop的实际应用)
  - [spring实现多线程安全](#spring实现多线程安全)
  - [spring的bean的高并发安全问题](#spring的bean的高并发安全问题)
  - [ioc aop总结（概述性）](#ioc-aop总结概述性)
  - [Spring 的加载流程，Spring 的源码中 Bean 的构造的流程](#spring-的加载流程spring-的源码中-bean-的构造的流程)
  - [Spring 事务源码，IOC 源码，AOP 源码](#spring-事务源码ioc-源码aop-源码)
  - [spring 的作用及理解 事务怎么配置](#spring-的作用及理解-事务怎么配置)
  - [spring事务失效情况](#spring事务失效情况)
  - [Spring 的 annotation 如何实现](#spring-的-annotation-如何实现)
  - [SpringMVC 工作原理](#springmvc-工作原理)
  - [了解 SpringMVC 与 Struct2 区别](#了解-springmvc-与-struct2-区别)
  - [springMVC 和 spring 是什么关系](#springmvc-和-spring-是什么关系)
  - [项目中 Spring 的 IOC 和 AOP 具体怎么使用的](#项目中-spring-的-ioc-和-aop-具体怎么使用的)
  - [spring mvc 底层实现原理](#spring-mvc-底层实现原理)
  - [动态代理的原理](#动态代理的原理)
  - [如果使用 spring mvc，那 post 请求跟 put 请求有什么区别啊； 然后开始问 springmvc：描述从 tomcat 开始到 springmvc 返回到前端显示的整个流程,接着问 springmvc 中的 handlerMapping 的内部实现，然后又问 spring 中从载入 xml 文件到 getbean 整个流程，描述一遍](#如果使用-spring-mvc那-post-请求跟-put-请求有什么区别啊-然后开始问-springmvc描述从-tomcat-开始到-springmvc-返回到前端显示的整个流程接着问-springmvc-中的-handlermapping-的内部实现然后又问-spring-中从载入-xml-文件到-getbean-整个流程描述一遍)
- [六 微服务（springboot等）](#六-微服务springboot等)
  - [springboot](#springboot)
  - [springcloud](#springcloud)
- [七 数据结构](#七-数据结构)
  - [二叉树相关](#二叉树相关)
  - [红黑树](#红黑树)
  1.结点是红色或黑色。
  2.根结点是黑色。
  3.每个叶子结点都是黑色的空结点（NIL结点）。
  4 每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)
  5.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。
  旋转和变色
  -[B-树，B树，B+树]
  1.根结点至少有两个子女。
  2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
  3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
  4.所有的叶子结点都位于同一层。
  5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。
  
  一个m阶的B+树具有如下几个特征：
  1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
  2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
  3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。
  B+树的优势：
  1.单一节点存储更多的元素，使得查询的IO次数更少。
  2.所有查询都要查找到叶子节点，查询性能稳定。
  3.所有叶子节点形成有序链表，便于范围查询。
  
- [八 数据库](#八-数据库)
- [MySQL](#mysql)
  - [数据库死锁问题](#数据库死锁问题)
  - [hash索引和B+树索引的区别](#hash索引和b树索引的区别)
  - [可重复的原理MVCC](#可重复的原理mvcc)
  - [count(1)、count(*)、count(列名)](#count1-count-count列名)
  - [mysql的undo、redo、binlog的区别](#mysql的undo-redo-binlog的区别)
  - [explain解释](#explain解释)
  - [mysql分页查询优化](#mysql分页查询优化)
  - [sql注入](#sql注入)
  - [为什么用B+树](#为什么用b树)
  - [sql执行流程](#sql执行流程)
  - [聚集索引与非聚集索引](#聚集索引与非聚集索引)
  - [覆盖索引](#覆盖索引)
  - [sql总结](#sql总结)
  - [有人建议给每张表都建一个自增主键，这样做有什么优点跟缺点](#有人建议给每张表都建一个自增主键这样做有什么优点跟缺点)
  - [对 MySQL 的了解，和 oracle 的区别](#对-mysql-的了解和-oracle-的区别)
  - [500万数字排序，内存只能容纳5万个，如何排序，如何优化？](#500万数字排序内存只能容纳5万个如何排序如何优化)
  - [平时怎么写数据库的模糊查询（由字典树扯到模糊查询，前缀查询，例如“abc%”，还是索引策略的问题）](#平时怎么写数据库的模糊查询由字典树扯到模糊查询前缀查询例如abc还是索引策略的问题)
  - [数据库里有 10000000 条用户信息，需要给每位用户发送信息（必须发送成功），要求节省内存](#数据库里有-10000000-条用户信息需要给每位用户发送信息必须发送成功要求节省内存)
  - [项目中如何实现事务](#项目中如何实现事务)
  - [数据库设计一般设计成第几范式](#数据库设计一般设计成第几范式)
  - [mysql 用的什么版本 5.7 跟 5.6 有啥区别](#mysql-用的什么版本-57-跟-56-有啥区别)
  - [提升 MySQL 安全性](#提升-mysql-安全性)
  - [问了一个这样的表(三个字段:姓名，id，分数)要求查出平均分大于 80 的 id 然后分数降序排序，然后经过提示用聚合函数 avg。](#问了一个这样的表三个字段姓名id分数要求查出平均分大于-80-的-id-然后分数降序排序然后经过提示用聚合函数-avg)
  - [为什么 mysql 事务能保证失败回滚](#为什么-mysql-事务能保证失败回滚)
  - [主键索引底层的实现原理](#主键索引底层的实现原理)
  - [经典的01索引问题？](#经典的01索引问题)
  - [如何在长文本中快捷的筛选出你的名字？](#如何在长文本中快捷的筛选出你的名字)
  - [多列索引及最左前缀原则和其他使用场景](#多列索引及最左前缀原则和其他使用场景)
  - [事务隔离级别](#事务隔离级别)
  - [索引的最左前缀原则](#索引的最左前缀原则)
  - [数据库悲观锁怎么实现的](#数据库悲观锁怎么实现的)
  - [建表的原则](#建表的原则)
  - [索引的内涵和用法](#索引的内涵和用法)
  - [给了两条 SQL 语句，让根据这两条语句建索引（个人想法：主要考虑复合索引只能匹配前缀列的特点）](#给了两条-sql-语句让根据这两条语句建索引个人想法主要考虑复合索引只能匹配前缀列的特点)
  - [那么我们来聊一下数据库。A 和 B 两个表做等值连接(Inner join) 怎么优化](#那么我们来聊一下数据库a-和-b-两个表做等值连接inner-join-怎么优化)
  - [数据库连接池的理解和优化](#数据库连接池的理解和优化)
  - [Sql语句分组排序](#sql语句分组排序)
  - [SQL语句的5个连接概念](#sql语句的5个连接概念)
  - [数据库优化和架构（主要是主从分离和分库分表相关）](#数据库优化和架构主要是主从分离和分库分表相关)
  - [分库分表](#分库分表)
  - [跨库join实现](#跨库join实现)
  - [探讨主从分离和分库分表相关](#探讨主从分离和分库分表相关)
  - [数据库中间件](#数据库中间件)
  - [读写分离在中间件的实现](#读写分离在中间件的实现)
  - [限流 and 熔断](#限流-and-熔断)
  - [行锁适用场景](#行锁适用场景)
- [Redis](#redis)
  - [redis为什么快？](#redis为什么快)
  - [Redis 数据结构原理](#redis-数据结构原理)
  - [Redis 持久化机制](#redis-持久化机制)
  - [Redis 的一致性哈希算法](#redis-的一致性哈希算法)
  - [redis了解多少](#redis了解多少)
  - [redis五种数据类型，当散列类型的 value 值非常大的时候怎么进行压缩](#redis五种数据类型当散列类型的-value-值非常大的时候怎么进行压缩)
  - [用redis怎么实现摇一摇与附近的人功能](#用redis怎么实现摇一摇与附近的人功能)
  - [redis 主从复制过程](#redis-主从复制过程)
  - [Redis 如何解决 key 冲突](#redis-如何解决-key-冲突)
  - [redis 是怎么存储数据的](#redis-是怎么存储数据的)
  - [redis 使用场景](#redis-使用场景)
- [九 计算机网络](#九-计算机网络)
  - [cookie 禁用怎么办](#cookie-禁用怎么办)
  - [Netty new 实例化过程](#netty-new-实例化过程)
  - [socket 实现过程，具体用的方法；怎么实现异步 socket.](#socket-实现过程具体用的方法怎么实现异步-socket)
  - [浏览器的缓存机制](#浏览器的缓存机制)
  - [http相关问题](#http相关问题)
  - [TCP三次握手第三次握手时ACK丢失怎么办](#tcp三次握手第三次握手时ack丢失怎么办)
  - [dns属于udp还是tcp，原因](#dns属于udp还是tcp原因)
  - [http的幂等性](#http的幂等性)
  - [建立连接的过程客户端跟服务端会交换什么信息(参考 TCP 报文结构)](#建立连接的过程客户端跟服务端会交换什么信息参考-tcp-报文结构)
  - [丢包如何解决重传的消耗](#丢包如何解决重传的消耗)
  - [traceroute 实现原理](#traceroute-实现原理)
  - [IO多路复用](#io多路复用)
  - [select 和 poll 区别？](#select-和-poll-区别)
  - [在不使用 WebSocket 情况下怎么实现服务器推送的一种方法](#在不使用-websocket-情况下怎么实现服务器推送的一种方法)
  - [可以使用客户端定时刷新请求或者和 TCP 保持心跳连接实现。](#可以使用客户端定时刷新请求或者和-tcp-保持心跳连接实现)
  - [查看磁盘读写吞吐量？](#查看磁盘读写吞吐量)
  - [PING 位于哪一层](#ping-位于哪一层)
  - [网络重定向，说下流程](#网络重定向说下流程)
  - [controller 怎么处理的请求：路由](#controller-怎么处理的请求路由)
  - [IP 地址分为几类，每类都代表什么，私网是哪些](#ip-地址分为几类每类都代表什么私网是哪些)
- [十 操作系统](#十-操作系统)
  - [Java I/O 底层细节，注意是底层细节，而不是怎么用](#java-io-底层细节注意是底层细节而不是怎么用)
  - [Java IO 模型(BIO,NIO 等) ，Tomcat 用的哪一种模型](#java-io-模型bionio-等-tomcat-用的哪一种模型)
  - [当获取第一个获取锁之后，条件不满足需要释放锁应当怎么做？](#当获取第一个获取锁之后条件不满足需要释放锁应当怎么做)
  - [手写一个线程安全的生产者与消费者。](#手写一个线程安全的生产者与消费者)
  - [进程和线程调度方法](#进程和线程调度方法)
- [linux](#linux)
  - [linux查找命令](#linux查找命令)
  - [项目部署常见linux命令](#项目部署常见linux命令)
  - [进程文件里有哪些信息](#进程文件里有哪些信息)
  - [sed 和 awk 的区别](#sed-和-awk-的区别)
  - [linux查看进程并杀死的命令](#linux查看进程并杀死的命令)
  - [有一个文件被锁住，如何查看锁住它的线程？](#有一个文件被锁住如何查看锁住它的线程)
  - [如何查看一个文件第100行到150行的内容](#如何查看一个文件第100行到150行的内容)
  - [如何查看进程消耗的资源](#如何查看进程消耗的资源)
  - [如何查看每个进程下的线程？](#如何查看每个进程下的线程)
  - [linux 如何查找文件](#linux-如何查找文件)
  - [select epoll等问题](#select-epoll等问题)
- [十一 框架其他](#十一-框架其他)
  - [Servlet 的 Filter 用的什么设计模式](#servlet-的-filter-用的什么设计模式)
  - [zookeeper 的常用功能，自己用它来做什么](#zookeeper-的常用功能自己用它来做什么)
  - [redis 的操作是不是原子操作](#redis-的操作是不是原子操作)
  - [秒杀业务场景设计](#秒杀业务场景设计)
  - [如何设计淘宝秒杀系统（重点关注架构，比如数据一致性，数据库集群一致性哈希，缓存， 分库分表等等）](#如何设计淘宝秒杀系统重点关注架构比如数据一致性数据库集群一致性哈希缓存-分库分表等等)
  - [对后台的优化有了解吗？比如负载均衡](#对后台的优化有了解吗比如负载均衡)
  - [对 Restful 了解 Restful 的认识，优点，以及和 soap 的区别](#对-restful-了解-restful-的认识优点以及和-soap-的区别)
  - [lrucache 的基本原理](#lrucache-的基本原理)
- [十二 设计模式](#十二-设计模式)
  - [Java常见设计模式](#java常见设计模式)
- [十三 分布式](#十三-分布式)
  - [dubbo中的dubbo协议和http协议有什么区别？](#dubbo中的dubbo协议和http协议有什么区别)
  - [负载均衡](#负载均衡)
  - [分布式锁的实现方式及优缺点](#分布式锁的实现方式及优缺点)
  - [CAP](#cap)
  - [如何实现分布式缓存](#如何实现分布式缓存)
- [十四 其他](#十四-其他)
    - [Java 8 函数式编程 回调函数](#java-8-函数式编程-回调函数)
  - [函数式编程，面向对象之间区别](#函数式编程面向对象之间区别)
  - [Java 8 中 stream 迭代的优势和区别？](#java-8-中-stream-迭代的优势和区别)
  - [同步等于可见性吗？](#同步等于可见性吗)
  - [git底层数据结构](#git底层数据结构)
  - [安全加密](#安全加密)
  - [web安全问题](#web安全问题)

<!-- /code_chunk_output -->


### 一 Java基础

#### 一致性hash算法

https://blog.csdn.net/qq_40551994/article/details/100991581

#### sleep和wait

https://blog.csdn.net/qq_20009015/article/details/89980966
https://blog.csdn.net/lengyue309/article/details/79639245

#### 强软弱虚引用

https://blog.csdn.net/junjunba2689/article/details/80601729

#### Arrays.sort原理

https://www.cnblogs.com/baichunyu/p/11935995.html

#### 创建对象的方式

https://blog.csdn.net/w410589502/article/details/56489294

#### 若hashcode方法永远返回1会产生什么结果

https://blog.csdn.net/cnq2328/article/details/50436175

#### 解决hash冲突的三种方法

https://blog.csdn.net/qq_32595453/article/details/80660676

#### 为什么要重写hashCode()方法和equals()方法以及如何进行重写

https://blog.csdn.net/xlgen157387/article/details/63683882

#### 动态代理

https://segmentfault.com/a/1190000011291179

#### sleep和wait的区别

https://blog.csdn.net/u012050154/article/details/50903326

#### java 地址和值传递的例子 

https://www.cnblogs.com/zhangyu317/p/11226105.html

#### Java序列化

https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf

####  java NIO，java 多线程、线程池，java 网络编程解决并发量

Java Nio使用：https://blog.csdn.net/forezp/article/details/88414741
Java Nio原理：https://www.cnblogs.com/crazymakercircle/p/10225159.html
线程池：http://cmsblogs.com/?p=2448
为什么nio快：https://blog.csdn.net/yaogao000/article/details/47972143

#### JDBC 连接的过程 ，手写 jdbc 连接过程 

https://blog.csdn.net/qq_44971038/article/details/103204217

#### 说出三个遇到过的程序报异常的情况 

https://www.cnblogs.com/winnie-man/p/10471338.html

#### socket 是靠什么协议支持的 

TCP/IP，协议。socket用于 通信，在实际应用中有im等，因此需要可靠的网络协议，UDP则是不可靠的协议，且服务端与客户端不链接，UDP用于广播，视频流等

#### java io 用到什么设计模式 

装饰模式和适配器模式

#### serviable 的序列化，其中 uuid 的作用 

相当于快递的打包和拆包，里面的东西要保持一致，不能人为的去改变他，不然就交易不成功。序列化与反序列化也是一样，而版本号的存在就是要是里面内容要是不一致，不然就报错。像一个防伪码一样。

#### 什么情景下会用到反射

注解、Spring 配置文件、动态代理、jdbc

#### 浅克隆与深克隆有什么区别，如何实现深克隆 

浅拷贝：仅仅克隆基本类型变量，而不克隆引用类型的变量
深克隆：既克隆基本类型变量，也克隆引用类型变量

1.浅克隆：只复制基本类型的数据，引用类型的数据只复制了引用的地址，引用的对象并没有复制，在新的对象中修改引用类型的数据会影响原对象中的引用。直接使用clone方法，再嵌套的还是浅克隆，因为有些引用类型不能直接克隆。
2.深克隆：是在引用类型的类中也实现了clone，是clone的嵌套，并且在clone方法中又对没有clone方法的引用类型又做差异化复制，克隆后的对象与原对象之间完全不会影响，但是内容完全相同。

#### 反射能够使用私有的方法属性吗和底层原理？ 

https://blog.51cto.com/4247649/2109128

#### 处理器指令优化有些什么考虑？ 

禁止重排序 

#### object 对象的常用方法 

#### Stack 和 ArrayList 的区别

#### statement 和 prestatement 的区别 

1、Statement用于执行静态SQL语句，在执行时，必须指定一个事先准备好的SQL语句。
2、PrepareStatement是预编译的SQL语句对象，sql语句被预编译并保存在对象中。被封装的sql语句代表某一类操作，语句中可以包含动态参数“?”，在执行时可以为“?”动态设置参数值。
3、使用PrepareStatement对象执行sql时，sql被数据库进行解析和编译，然后被放到命令缓冲区，每当执行同一个PrepareStatement对象时，它就会被解析一次，但不会被再次编译。在缓冲区可以发现预编译的命令，并且可以重用。
4、PrepareStatement可以减少编译次数提高数据库性能。

#### 手写模拟实现一个阻塞队列

https://www.cnblogs.com/keeya/p/9713686.html

#### util 包下有哪几种接口 

#### 很常见的 Nullpointerexception ，你是怎么排查的，怎么解决的； 

#### 静态内部类和非静态内部类的区别是什么？

#### 怎么创建静态内部类和非静态内部类？ 

https://blog.csdn.net/qq_38366777/article/details/78088386

#### Xml 解析方式，原理优缺点 

https://segmentfault.com/a/1190000013504078?utm_source=tag-newest  

#### 静态变量和全局变量的区别


### 二 Java集合

#### hashmap的jdk1.7和jdk1.8区别

https://juejin.im/post/5aa5d8d26fb9a028d2079264

https://blog.csdn.net/qq_36520235/article/details/82417949

#### concurrenthashmap的jdk1.7和jdk1.8区别

https://juejin.im/post/5df8d7346fb9a015ff64eaf9

#### HashMap 实现原理，扩容因子过大过小的缺点，扩容过程 采用什么方法能保证每个 bucket 中的数据更均匀 解决冲突的方式，还有没有其他方式（全域哈希）

扩容：https://www.jianshu.com/p/5730bff593ed

https://www.cnblogs.com/peizhe123/p/5790252.html

#### Collection 集合类中只能在 Iterator 中删除元素的原因 

在Iterator的内部有个expectedModCount 变量，
该变量每次初始化Iterator的时候等于ArrayList的modCount，modCount记录了对ArrayList的结构修改次数，
在通过Iterator对ArrayList进行结构的修改的时候都会将expectedModCount 与modCount同步，但是如果在通过Iterator访问的时候同时又通过索引的方式去修改ArrayList的结构的话，由于通过索引的方式只会修改modCount不会同步修改expectedModCount 就会导致modCount和expectedModCount 不相等就会抛ConcurrentModificationException，
这也就是Iterator的fail-fast，快速失效的。所以只要采取一种方式操作ArrayList就不会出问题，
当然ArrayList不是线程安全的，此处不讨论对线程问题。

更加详细的解释
https://blog.csdn.net/yanshuanche3765/article/details/78917507

#### ArrayList、LinkedList、Vector

https://blog.csdn.net/zhangqiluGrubby/article/details/72870493

##### 还了解除 util 其他包下的 List 吗？

##### CopyOnWriteArrayList 

（1）CopyOnWriteArrayList使用ReentrantLock重入锁加锁，保证线程安全；
（2）CopyOnWriteArrayList的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是O(n)，性能比较低下；
（3）CopyOnWriteArrayList的读操作支持随机访问，时间复杂度为O(1)；
（4）CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合；
（5）CopyOnWriteArrayList只保证最终一致性，不保证实时一致性；

#### ConcurrentHashMap 和 LinkedHashMap 差异和适用情形 

哈希表的原理：https://blog.csdn.net/yyyljw/article/details/80903391

可以以下方面进行回答
（1）使用的数据结构？
（2）添加元素、删除元素的基本逻辑？
（3）是否是fail-fast的？
（4）是否需要扩容？扩容规则？
（5）是否有序？是按插入顺序还是自然顺序还是访问顺序？
（6）是否线程安全？
（7）使用的锁？
（8）优点？缺点？
（9）适用的场景？
（10）时间复杂度？
（11）空间复杂度？

#### ConcurrentHashMap分段锁是如何实现，ConcurrentHashmap jdk1.8 访问的时候是怎么加锁的，插入的时候是怎么加锁的 访问不加 锁插入的时候对头结点加锁

jdk1.8；https://blog.csdn.net/weixin_42130471/article/details/89813248

#### ArrayDeque 的使用场景 

1、用数组实现的双端队列
2、线程不是安全的
3、可以用来实现栈

#### ArrayBlockingQueue 源码

http://cmsblogs.com/?p=4755

（1）ArrayBlockingQueue不需要扩容，因为是初始化时指定容量，并循环利用数组；
（2）ArrayBlockingQueue利用takeIndex和putIndex循环利用数组；
（3）入队和出队各定义了四组方法为满足不同的用途；
（4）利用重入锁和两个条件保证并发安全：lock、notEmpty、notFull

####  hashmap 和 treemap 的区别 

http://cmsblogs.com/?p=4743

##### hashmap

（1）HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；
（2）HashMap的默认初始容量为16（1<<4），默认装载因子为0.75f，容量总是2的n次方；
（3）HashMap扩容时每次容量变为原来的两倍；
（4）当桶的数量小于64时不会进行树化，只会扩容；
（5）当桶的数量大于64且单个桶中元素的数量大于8时，进行树化；
（6）当单个桶中元素数量小于6时，进行反树化；
（7）HashMap是非线程安全的容器；
（8）HashMap查找添加元素的时间复杂度都为O(1)；

##### treemap

（1）TreeMap的存储结构只有一颗红黑树；
（2）TreeMap中的元素是有序的，按key的顺序排列；
（3）TreeMap比HashMap要慢一些，因为HashMap前面还做了一层桶，寻找元素要快很多；
（4）TreeMap没有扩容的概念；
（5）TreeMap的遍历不是采用传统的递归式遍历；
（6）TreeMap可以按范围查找元素，查找最近的元素；

#### rehash 过程 

https://www.jianshu.com/p/dde9b12343c1

#### HashMap 的负载因子，为什么容量为2^n

HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法； 这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&(length-1)， hash%length==hash&(length-1)的前提是length是2的n次方； 为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1； 例如长度为9时候，3&(9-1)=0  2&(9-1)=0 ，都在0上，碰撞了； 例如长度为8时候，3&(8-1)=3  2&(8-1)=2 ，不同位置上，不碰撞； 其实就是按位“与”的时候，每一位都能  &1  ，也就是和1111……1111111进行与运算

#### list,map,set 之间的区别 

https://blog.csdn.net/u012102104/article/details/79235938

#### 什么时候会用到 HashMap 

#### 常见的线程安全的集合类 


### 三 JVM

#### 反射在jvm层面的实现

https://www.jianshu.com/p/b6cb4c694951

#### jvm的方法区存什么？

https://www.jianshu.com/p/10584345b10a

#### JDK1.8 JVM方法区变成了什么，为什么这样做

https://blog.csdn.net/u011665991/article/details/107141348/

#### oom出现的原因

https://blog.csdn.net/iteye_9584/article/details/82583093

#### Class.forName和ClassLoader的区别

https://blog.csdn.net/qq_27093465/article/details/52262340

#### java对象信息分配

https://blog.csdn.net/u014520047/article/details/81940447

#### java虚拟机ZGC详解

https://vimsky.com/article/4162.html

#### java虚拟机CMS详解

https://juejin.im/post/5c7262a15188252f30484351

#### java虚拟机G1详解

https://zhuanlan.zhihu.com/p/59861022

#### JVM tomcat 容器启动，jvm 加载情况描述 

tomcat请求流程：http://objcoding.com/2017/06/12/Tomcat-structure-and-processing-request-process/

其实就是jvm的类加载情况，非常相似
https://blog.csdn.net/lduzhenlin/article/details/83013143
https://blog.csdn.net/xlgen157387/article/details/53521928

### 四 多线程并发

#### volitale使用场景

https://blog.csdn.net/vking_wang/article/details/9982709

#### 可重入锁,实现原理 

ReetrantLock：https://www.jianshu.com/p/f8f6ac49830e

#### Java 无锁原理 

https://blog.csdn.net/qq_39291929/article/details/81501829

#### 讲讲多线程，多线程的同步方法

#### synchronized原理

https://www.jianshu.com/p/d53bf830fa09

#### reetrantlock

#### java 线程安全都体现在哪些方面

#### 如果维护线程安全 如果想实现一个线程安全的队列，可以怎么实现？ 

JUC 包里的 ArrayBlockingQueue 还有 LinkedBlockingQueue 啥的又结合源码说了一通。

#### Java多线程通信方式

https://blog.csdn.net/u011514810/article/details/77131296
https://blog.csdn.net/xiaokang123456kao/article/details/77331878

#### CountDownLatch、CyclicBarrier、Semaphore 用法总结

https://segmentfault.com/a/1190000012234469

#### juc下的内容

https://blog.csdn.net/sixabs/article/details/98471709

#### AOS等并发相关面试题

https://cloud.tencent.com/developer/article/1471770
https://zhuanlan.zhihu.com/p/96544118
https://zhuanlan.zhihu.com/p/48295486

#### threadlocal
https://juejin.im/post/5ac2eb52518825555e5e06ee

#### java 线程池达到提交上限的具体情况 ，线程池用法，Java 多线程，线程池有哪几类，每一类的差别 

https://blog.csdn.net/github_37130188/article/details/89504500

#### 要你设计的话，如何实现一个线程池 

http://www.vcchar.com/thread-29098-1-1.html

#### 线程池的类型，固定大小的线程池内部是如何实现的，等待队列是用了哪一个队列实现 线程池种类和工作流程

重点讲 newcached 线程池 线程池工作原理 比如 corePoolSize 和maxPoolSize 这两个参数该怎么调 

http://cmsblogs.com/?p=2448

#### 线程池使用了什么设计模式 

#### 线程池使用时一般要考虑哪些问题 

https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14

#### 线程池的配置 

#### Excutor 以及 Connector 的配置

https://www.cnblogs.com/kismetv/p/7806063.html


### 五 Java框架（ssm）

### hibernate

#### Hibernate 的生成策略

主要说了 native 、uuid 

https://blog.csdn.net/itmyhome1990/article/details/54863822

#### Hibernate 与 Mybatis 区别

https://blog.csdn.net/wangpeng047/article/details/17038659

#### Mybatis原理

https://www.javazhiyin.com/34438.html

#### mybatis执行select的过程

https://www.jianshu.com/p/ae2bda8f9d84
https://blog.csdn.net/qwesxd/article/details/90049863

#### mybatis有哪些executors

https://blog.csdn.net/weixin_42495773/article/details/106799280
https://blog.csdn.net/weixin_34025051/article/details/92405286

#### mybatis插件原理

https://www.cnblogs.com/qdhxhz/p/11390778.html


#### mybatis二级缓存

https://blog.csdn.net/csdnliuxin123524/article/details/78874261


### spring&springmvc

面试题：
https://mp.weixin.qq.com/s/2Y5X11TycreHgO0R3agK2A 
https://mp.weixin.qq.com/s/IdjCxumDleLqdU8MgQnrLQ

#### spring中的设计模式

https://juejin.im/post/5ce69379e51d455d877e0ca0

#### spring中bean的作用域

https://blog.csdn.net/weidaoyouwen/article/details/80503575

#### BeanFactory和FactoryBean区别

https://blog.csdn.net/weixin_38361347/article/details/92852611

#### aspect的种类

https://blog.csdn.net/StubbornAccepted/article/details/70767014

#### spring aop的实际应用

https://blog.csdn.net/zzh_spring/article/details/107207025

#### spring实现多线程安全

https://www.cnblogs.com/tiancai/p/9627109.html

#### spring的bean的高并发安全问题

https://blog.csdn.net/songzehao/article/details/103365494/

#### ioc aop总结（概述性）

https://juejin.im/post/5b040cf66fb9a07ab7748c8b
https://juejin.im/post/5b06bf2df265da0de2574ee1

#### Spring 的加载流程，Spring 的源码中 Bean 的构造的流程 

spring ioc系列文章：http://cmsblogs.com/?p=2806
加载流程（概述）：https://www.jianshu.com/p/5fd1922ccab1
循环依赖问题：https://blog.csdn.net/u010853261/article/details/77940767
https://blog.csdn.net/a15119273009/article/details/108007864


#### Spring 事务源码，IOC 源码，AOP 源码

https://juejin.im/post/5c525968e51d453f5e6b744b

ioc、aop系列源码：
https://segmentfault.com/a/1190000015319623
http://www.tianxiaobo.com/2018/05/30/Spring-IOC-%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/

#### spring 的作用及理解 事务怎么配置

https://www.jianshu.com/p/e7d59ebf41a3

#### spring事务失效情况

https://blog.csdn.net/luo4105/article/details/79733338

#### Spring 的 annotation 如何实现 
https://segmentfault.com/a/1190000013258647

#### SpringMVC 工作原理 

https://blog.csdn.net/cswhale/article/details/16941281

#### 了解 SpringMVC 与 Struct2 区别 

https://blog.csdn.net/chenleixing/article/details/44570681

#### springMVC 和 spring 是什么关系 


#### 项目中 Spring 的 IOC 和 AOP 具体怎么使用的 

https://www.cnblogs.com/xdp-gacl/p/4249939.html
https://juejin.im/post/5b06bf2df265da0de2574ee1

#### spring mvc 底层实现原理 

https://blog.csdn.net/weixin_42323802/article/details/84038765

#### 动态代理的原理 

https://juejin.im/post/5a3284a75188252970793195

#### 如果使用 spring mvc，那 post 请求跟 put 请求有什么区别啊； 然后开始问 springmvc：描述从 tomcat 开始到 springmvc 返回到前端显示的整个流程,接着问 springmvc 中的 handlerMapping 的内部实现，然后又问 spring 中从载入 xml 文件到 getbean 整个流程，描述一遍


### 六 微服务（springboot等）

#### springboot

[springboot面试题](https://mp.weixin.qq.com/s/id0Ga1OC4D3Hu6lkzc9hRg)
[springboot面试题2](https://mp.weixin.qq.com/s/XGIErbCx2i6Y8vBgw1gq_Q)

#### springcloud

[springcloud面试题](https://mp.weixin.qq.com/s/CYfLA9s9zhwcIwJjMFXhQQ)


### 七 数据结构

#### 二叉树相关

https://www.jianshu.com/p/655d83f9ba7b
https://www.jianshu.com/p/ff4b93b088eb

#### 红黑树

https://www.jianshu.com/p/e136ec79235c
https://zhuanlan.zhihu.com/p/31805309



### 八 数据库

### MySQL

#### 数据库死锁问题

https://blog.csdn.net/cbjcry/article/details/84920174

#### hash索引和B+树索引的区别

https://www.cnblogs.com/heiming/p/5865101.html

#### 可重复的原理MVCC

https://www.cnblogs.com/wade-luffy/p/8686883.html
https://blog.csdn.net/weixin_42041027/article/details/100587435
https://www.jianshu.com/p/8845ddca3b23

#### count(1)、count(*)、count(列名)

https://blog.csdn.net/iFuMI/article/details/77920767

#### mysql的undo、redo、binlog的区别

https://mp.weixin.qq.com/s/0z6GmUp0Lb1hDUo0EyYiUg

#### explain解释

https://segmentfault.com/a/1190000010293791

#### mysql分页查询优化

https://blog.csdn.net/hanchao5272/article/details/102790490

#### sql注入

https://blog.csdn.net/github_36032947/article/details/78442189

#### 为什么用B+树

https://blog.csdn.net/xlgen157387/article/details/79450295

#### sql执行流程

https://juejin.im/post/5b7036de6fb9a009c40997eb

#### 聚集索引与非聚集索引

https://juejin.im/post/5cdd701ee51d453a36384939

#### 覆盖索引

https://www.jianshu.com/p/77eaad62f974

#### sql总结

https://juejin.im/post/5d3f9cc1f265da03a31d1192

#### 有人建议给每张表都建一个自增主键，这样做有什么优点跟缺点

https://blog.csdn.net/yixuandong9010/article/details/72286029

#### 对 MySQL 的了解，和 oracle 的区别

https://juejin.im/post/5cbdbb455188250ab224802d

#### 500万数字排序，内存只能容纳5万个，如何排序，如何优化？ 
参考文章：https://juejin.im/entry/5a27cb796fb9a045104a5e8c

#### 平时怎么写数据库的模糊查询（由字典树扯到模糊查询，前缀查询，例如“abc%”，还是索引策略的问题） 

#### 数据库里有 10000000 条用户信息，需要给每位用户发送信息（必须发送成功），要求节省内存

#### 项目中如何实现事务 

#### 数据库设计一般设计成第几范式 

https://blog.csdn.net/hsd2012/article/details/51018631

#### mysql 用的什么版本 5.7 跟 5.6 有啥区别 

#### 提升 MySQL 安全性

https://blog.csdn.net/listen_for/article/details/53907270

#### 问了一个这样的表(三个字段:姓名，id，分数)要求查出平均分大于 80 的 id 然后分数降序排序，然后经过提示用聚合函数 avg。 

select id from table group by id having avg(score) > 80 order by avg(score) desc。 

#### 为什么 mysql 事务能保证失败回滚 

#### 主键索引底层的实现原理
B+树 

#### 经典的01索引问题？ 

#### 如何在长文本中快捷的筛选出你的名字？

全文索引 

#### 多列索引及最左前缀原则和其他使用场景 

#### 事务隔离级别

#### 索引的最左前缀原则 

#### 数据库悲观锁怎么实现的 

https://www.jianshu.com/p/f5ff017db62a

#### 建表的原则 

#### 索引的内涵和用法 

#### 给了两条 SQL 语句，让根据这两条语句建索引（个人想法：主要考虑复合索引只能匹配前缀列的特点） 

#### 那么我们来聊一下数据库。A 和 B 两个表做等值连接(Inner join) 怎么优化 

https://blog.csdn.net/hguisu/article/details/5731880

哈希 

#### 数据库连接池的理解和优化 
 

#### Sql语句分组排序 

#### SQL语句的5个连接概念 

#### 数据库优化和架构（主要是主从分离和分库分表相关） 

#### 分库分表 

#### 跨库join实现 

#### 探讨主从分离和分库分表相关 

#### 数据库中间件 

#### 读写分离在中间件的实现 

#### 限流 and 熔断 

#### 行锁适用场景

https://cloud.tencent.com/developer/article/1104098


### Redis 

#### redis为什么快？

https://zhuanlan.zhihu.com/p/57089960

#### Redis 数据结构原理 

https://blog.csdn.net/jackFXX/article/details/82318080

#### Redis 持久化机制 

#### Redis 的一致性哈希算法 

#### redis了解多少 

#### redis五种数据类型，当散列类型的 value 值非常大的时候怎么进行压缩

#### 用redis怎么实现摇一摇与附近的人功能

https://blog.csdn.net/smartwu_sir/article/details/80254733

#### redis 主从复制过程

#### Redis 如何解决 key 冲突 

#### redis 是怎么存储数据的 

#### redis 使用场景

### 九 计算机网络

#### cookie 禁用怎么办 

https://segmentfault.com/q/1010000007715137

#### Netty new 实例化过程 

#### socket 实现过程，具体用的方法；怎么实现异步 socket. 

https://blog.csdn.net/charjay_lin/article/details/81810922

#### 浏览器的缓存机制

说明计算机网络的知识还没有记住

https://www.cnblogs.com/yangyangxxb/p/10218871.html

#### http相关问题

https://mp.weixin.qq.com/s/xSGD3rWdboeeQvaS8jEchw

#### TCP三次握手第三次握手时ACK丢失怎么办

https://www.cnblogs.com/wuyepeng/p/9801470.html

#### dns属于udp还是tcp，原因

https://www.zhihu.com/question/310145373

#### http的幂等性

https://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html

#### 建立连接的过程客户端跟服务端会交换什么信息(参考 TCP 报文结构) 

#### 丢包如何解决重传的消耗 

https://cloud.tencent.com/developer/article/1195037

#### traceroute 实现原理 

https://zhuanlan.zhihu.com/p/36811672

#### IO多路复用

https://sanyuesha.com/python-server-tutorial/book/ch05.html

#### select 和 poll 区别？ 

好文：https://www.jianshu.com/p/dfd940e7fca2

#### 在不使用 WebSocket 情况下怎么实现服务器推送的一种方法

服务器推送：https://juejin.im/post/5c20e5766fb9a049b13e387b

#### 可以使用客户端定时刷新请求或者和 TCP 保持心跳连接实现。 

#### 查看磁盘读写吞吐量？ 

https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858810.html

#### PING 位于哪一层 

 ping命令本身相当于一个应用程序，位于应用层，虽然它使用的是ICMP协议，就好像HTTP位于应用层，但是也是使用的TCP协议

#### 网络重定向，说下流程 

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Redirections

#### controller 怎么处理的请求：路由

#### IP 地址分为几类，每类都代表什么，私网是哪些

https://zhuanlan.zhihu.com/p/54593244


### 十 操作系统

#### Java I/O 底层细节，注意是底层细节，而不是怎么用 

可以从Java IO底层、JavaIO模型（阻塞、异步等）
https://www.cnblogs.com/crazymakercircle/p/10225159.html

#### Java IO 模型(BIO,NIO 等) ，Tomcat 用的哪一种模型 

tomcat支持：https://blog.csdn.net/fd2025/article/details/80007435

#### 当获取第一个获取锁之后，条件不满足需要释放锁应当怎么做？ 

https://www.jianshu.com/p/eb112b25b848

#### 手写一个线程安全的生产者与消费者。 

https://blog.csdn.net/u010983881/article/details/78554671

#### 进程和线程调度方法

https://www.jianshu.com/p/91c8600cb2ae

### linux

#### linux查找命令

https://blog.51cto.com/whylinux/2043871

#### 项目部署常见linux命令

https://blog.csdn.net/u010938610/article/details/79625988

#### 进程文件里有哪些信息

#### sed 和 awk 的区别 

awk用法：https://www.cnblogs.com/isykw/p/6258781.html

其实sed和awk都是每次读入一行来处理的，区别是：sed 适合简单的文本替换和搜索；而awk除了自动给你分列之外，里面丰富的函数大大增强了awk的功能。数据统计，正则表达式搜索，逻辑处理，前后置脚本等。因此基本上sed能做的，awk可以全部完成并且做的更好。

作者：哩掉掉
链接：https://www.zhihu.com/question/297858714/answer/572046422
 
#### linux查看进程并杀死的命令

https://blog.csdn.net/qingmu0803/article/details/38271077

#### 有一个文件被锁住，如何查看锁住它的线程？
#### 如何查看一个文件第100行到150行的内容

https://blog.csdn.net/zmx19951103/article/details/78575265

#### 如何查看进程消耗的资源
https://www.cnblogs.com/freeweb/p/5407105.html

#### 如何查看每个进程下的线程？

https://blog.csdn.net/inuyashaw/article/details/55095545

#### linux 如何查找文件

linux命令：https://juejin.im/post/5d3857eaf265da1bd04f2437

#### select epoll等问题

https://juejin.im/post/5b624f4d518825068302aee9#heading-13

### 十一 框架其他

#### Servlet 的 Filter 用的什么设计模式 

https://www.jianshu.com/p/e4197a54828d

#### zookeeper 的常用功能，自己用它来做什么 

#### redis 的操作是不是原子操作 

https://juejin.im/entry/58f9e22044d9040069d40dca

#### 秒杀业务场景设计 

#### 如何设计淘宝秒杀系统（重点关注架构，比如数据一致性，数据库集群一致性哈希，缓存， 分库分表等等）


#### 对后台的优化有了解吗？比如负载均衡

我给面试官说了 Ngix+Tomcat 负载均 衡，异步处理（消息缓冲服务器），缓存(Redis， Memcache)， NoSQL，数据库优化，存储索引优化


#### 对 Restful 了解 Restful 的认识，优点，以及和 soap 的区别 

https://www.ruanyifeng.com/blog/2011/09/restful.html

#### lrucache 的基本原理 


### 十二 设计模式

#### Java常见设计模式

- https://www.jianshu.com/p/61b67ca754a3
- 单例模式（双检锁模式）、简单工厂、观察者模式、适配器模式、职责链模式等等 
- 享元模式模式 选两个画下 UML 图 
- 手写单例 
写的是静态内部类的单例，然后他问我这个地方为什么用 private，这儿为啥用 static, 这就考察你的基本功啦 
- 静态类与单例模式的区别 
- 单例模式 double check 单例模式都有什么，都是否线程安全，怎么改进（从 synchronized 到 双重检验锁 到 枚举 Enum）
- 基本的设计模式及其核心思想 
- 来，我们写一个单例模式的实现

### 十三 分布式

#### dubbo中的dubbo协议和http协议有什么区别？

https://blog.csdn.net/wjw_77/article/details/99696757

#### 负载均衡

https://juejin.im/post/5b39eea0e51d4558c1010e36

#### 分布式锁的实现方式及优缺点

https://zhuanlan.zhihu.com/p/62158041

#### CAP

https://www.jianshu.com/p/8025e3346734

#### 如何实现分布式缓存 

redis如何实现分布式缓存
https://stor.51cto.com/art/201912/607229.htm

### 十四 其他

##### Java 8 函数式编程 回调函数

#### 函数式编程，面向对象之间区别 

#### Java 8 中 stream 迭代的优势和区别？ 

#### 同步等于可见性吗？

保证了可见性不等于正确同步，因为还有原子性没考虑。 

#### git底层数据结构

https://blog.csdn.net/leo187/article/details/106233706

#### 安全加密

http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html
https://yq.aliyun.com/articles/54155

#### web安全问题

https://juejin.im/post/5da44c5de51d45783a772a22
